{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Create base HTML structure and page metadata",
        "description": "Set up index.html with semantic HTML5 structure, meta tags, and SEO/social sharing metadata",
        "details": "Create the index.html file with:\n\n1. DOCTYPE and HTML5 boilerplate\n2. Meta tags in <head>:\n   - charset UTF-8\n   - viewport for responsive design\n   - Page title: 'ReFi Orbifier - Transform Your Profile Picture'\n   - Meta description summarizing the tool\n   - Open Graph tags (og:title, og:description, og:image, og:url, og:type)\n   - Twitter Card meta tags (twitter:card, twitter:title, twitter:description, twitter:image)\n3. Link to Switzer font from Fontshare CDN:\n   <link href=\"https://api.fontshare.com/v2/css?f[]=switzer@300,500&display=swap\" rel=\"stylesheet\">\n4. Favicon link (pointing to assets/favicon.ico)\n5. Semantic HTML structure matching the PRD wireframe:\n   - <header> with logo area and tagline\n   - <section id=\"api-key-section\"> for API key management\n   - <section id=\"upload-section\"> for file upload\n   - <section id=\"result-section\"> for preview and actions (initially hidden)\n   - <footer> with attribution\n6. Include inline <style> tag for CSS (to be filled in next task)\n7. Include inline <script> tag for JavaScript (to be filled in later tasks)\n\nPseudo-structure:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <!-- Meta tags -->\n  <!-- Font link -->\n  <style>/* CSS here */</style>\n</head>\n<body>\n  <header>\n    <div class=\"logo\"><!-- SVG orb logo --></div>\n    <h1>ReFi Orbifier</h1>\n    <p>Transform your PFP with the ReFi orb</p>\n  </header>\n  \n  <main>\n    <section id=\"api-key-section\"><!-- API key form --></section>\n    <section id=\"upload-section\"><!-- Upload dropzone --></section>\n    <section id=\"result-section\" hidden><!-- Preview and buttons --></section>\n  </main>\n  \n  <footer><!-- Attribution --></footer>\n  <script>/* JavaScript here */</script>\n</body>\n</html>\n```",
        "testStrategy": "Manual verification:\n1. Validate HTML5 with W3C validator\n2. Check meta tags appear correctly in browser dev tools\n3. Test Open Graph preview using opengraph.xyz or Facebook Debugger\n4. Verify Twitter Card preview using Twitter Card Validator\n5. Confirm Switzer font loads (check Network tab)\n6. Test semantic structure with screen reader (VoiceOver/NVDA)",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:19:52.420Z"
      },
      {
        "id": "2",
        "title": "Implement CSS styling and responsive design",
        "description": "Create all visual styling matching ReFi DAO brand guidelines with dark mode aesthetic and responsive breakpoints",
        "details": "Implement comprehensive CSS within the <style> tag in index.html:\n\n1. CSS Custom Properties for brand colors:\n```css\n:root {\n  --refi-space: #172027;\n  --refi-blue: #4571E1;\n  --refi-green: #71E3BA;\n  --refi-yellow: #FFFA7E;\n  --refi-pink: #DE9AE9;\n  --refi-cloud: #F1F0FF;\n}\n```\n\n2. Global styles:\n   - Body background: var(--refi-space) with subtle radial gradient\n   - Font family: 'Switzer', fallback stack\n   - Color: var(--refi-cloud)\n   - Box-sizing: border-box reset\n\n3. Typography:\n   - H1: Switzer Medium (500), appropriate sizing\n   - Body: Switzer Light (300)\n   - Proper hierarchy and spacing\n\n4. Component styles:\n   - Header with centered logo and text\n   - API key section: input field, toggle visibility button, save button\n   - Upload dropzone: dashed border, hover/drag states, icon styling\n   - Result section: centered preview, action buttons\n   - Footer: subtle, centered\n\n5. Interactive states:\n   - Button hovers with smooth transitions (0.2s ease)\n   - Focus indicators for accessibility (2px solid outline)\n   - Disabled states with reduced opacity\n   - Loading states (skeleton, spinners)\n\n6. Responsive breakpoints:\n   - Mobile first (base styles for <480px)\n   - @media (min-width: 480px): minor adjustments\n   - @media (min-width: 768px): two-column layouts where appropriate\n   - @media (min-width: 1024px): max-width container, optimal spacing\n\n7. Utility classes:\n   - .hidden { display: none; }\n   - .loading { opacity: 0.6; pointer-events: none; }\n   - .error { color: #ff6b6b; border-color: #ff6b6b; }\n\n8. Ensure minimum tap target size of 44px for touch interfaces\n\n9. Color contrast ratios meeting WCAG 2.1 AA (4.5:1 for text)",
        "testStrategy": "Testing checklist:\n1. Visual regression against PRD wireframe on multiple viewports\n2. Test on physical devices: iPhone SE, iPad, desktop\n3. Verify responsive breakpoints in Chrome DevTools\n4. Color contrast audit using axe DevTools or WAVE\n5. Test all interactive states (hover, focus, active, disabled)\n6. Verify smooth transitions and no layout shift\n7. Test with 200% browser zoom for accessibility\n8. Dark mode appearance matches ReFi DAO branding\n9. Cross-browser testing: Chrome, Firefox, Safari, Edge",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:19:54.148Z"
      },
      {
        "id": "3",
        "title": "Implement API key management with localStorage",
        "description": "Build client-side API key input, validation, storage, and management functionality",
        "details": "JavaScript implementation for API key management:\n\n1. DOM references:\n```javascript\nconst apiKeyInput = document.getElementById('api-key-input');\nconst apiKeyToggle = document.getElementById('api-key-toggle');\nconst apiKeySave = document.getElementById('api-key-save');\nconst apiKeyClear = document.getElementById('api-key-clear');\n```\n\n2. localStorage key constant: 'refi-orbifier-api-key'\n\n3. On page load:\n```javascript\nwindow.addEventListener('DOMContentLoaded', () => {\n  const savedKey = localStorage.getItem('refi-orbifier-api-key');\n  if (savedKey) {\n    apiKeyInput.value = savedKey;\n    enableUploadSection();\n  }\n});\n```\n\n4. Save API key:\n```javascript\napiKeySave.addEventListener('click', () => {\n  const key = apiKeyInput.value.trim();\n  if (validateApiKeyFormat(key)) {\n    localStorage.setItem('refi-orbifier-api-key', key);\n    showSuccessMessage('API key saved!');\n    enableUploadSection();\n  } else {\n    showErrorMessage('Invalid API key format');\n  }\n});\n```\n\n5. Validate API key format:\n```javascript\nfunction validateApiKeyFormat(key) {\n  // remove.bg keys are typically alphanumeric, 20-40 chars\n  return /^[A-Za-z0-9]{20,50}$/.test(key);\n}\n```\n\n6. Toggle visibility:\n```javascript\napiKeyToggle.addEventListener('click', () => {\n  const type = apiKeyInput.type === 'password' ? 'text' : 'password';\n  apiKeyInput.type = type;\n  // Update icon (eye/eye-slash)\n});\n```\n\n7. Clear API key:\n```javascript\napiKeyClear.addEventListener('click', () => {\n  if (confirm('Remove saved API key?')) {\n    localStorage.removeItem('refi-orbifier-api-key');\n    apiKeyInput.value = '';\n    disableUploadSection();\n  }\n});\n```\n\n8. Helper to get stored key:\n```javascript\nfunction getApiKey() {\n  return localStorage.getItem('refi-orbifier-api-key');\n}\n```\n\n9. UI state management to show/hide upload section based on API key presence",
        "testStrategy": "Testing plan:\n1. Unit tests for validateApiKeyFormat() with valid/invalid keys\n2. Test localStorage persistence across page refreshes\n3. Verify show/hide toggle works correctly\n4. Test clear functionality with confirmation dialog\n5. Verify upload section disabled without API key\n6. Test with empty string, whitespace, special characters\n7. Privacy: confirm API key never sent to any server except remove.bg\n8. Cross-browser localStorage compatibility\n9. Test in private/incognito mode (localStorage available)\n10. Keyboard accessibility (tab navigation, Enter to save)",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:19:55.892Z"
      },
      {
        "id": "4",
        "title": "Build image upload with drag-and-drop and file validation",
        "description": "Implement file upload interface supporting drag-and-drop and click-to-browse with client-side validation",
        "details": "JavaScript implementation for image upload:\n\n1. DOM references:\n```javascript\nconst dropzone = document.getElementById('dropzone');\nconst fileInput = document.getElementById('file-input');\nconst uploadPreview = document.getElementById('upload-preview');\n```\n\n2. File validation constants:\n```javascript\nconst ALLOWED_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp'];\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes\n```\n\n3. Click to browse:\n```javascript\ndropzone.addEventListener('click', () => {\n  fileInput.click();\n});\n\nfileInput.addEventListener('change', (e) => {\n  if (e.target.files.length > 0) {\n    handleFile(e.target.files[0]);\n  }\n});\n```\n\n4. Drag and drop handlers:\n```javascript\ndropzone.addEventListener('dragover', (e) => {\n  e.preventDefault();\n  dropzone.classList.add('drag-over');\n});\n\ndropzone.addEventListener('dragleave', () => {\n  dropzone.classList.remove('drag-over');\n});\n\ndropzone.addEventListener('drop', (e) => {\n  e.preventDefault();\n  dropzone.classList.remove('drag-over');\n  if (e.dataTransfer.files.length > 0) {\n    handleFile(e.dataTransfer.files[0]);\n  }\n});\n```\n\n5. File validation and handling:\n```javascript\nfunction handleFile(file) {\n  // Validate file type\n  if (!ALLOWED_TYPES.includes(file.type)) {\n    showError('Please upload a PNG, JPG, or WEBP image');\n    return;\n  }\n  \n  // Validate file size\n  if (file.size > MAX_FILE_SIZE) {\n    showError('Image must be under 10MB');\n    return;\n  }\n  \n  // Show preview\n  const reader = new FileReader();\n  reader.onload = (e) => {\n    uploadPreview.src = e.target.result;\n    uploadPreview.style.display = 'block';\n    // Store file for processing\n    window.uploadedFile = file;\n    // Enable process button\n    enableProcessButton();\n  };\n  reader.readAsDataURL(file);\n}\n```\n\n6. Clear uploaded image:\n```javascript\nfunction clearUpload() {\n  fileInput.value = '';\n  uploadPreview.src = '';\n  uploadPreview.style.display = 'none';\n  window.uploadedFile = null;\n  disableProcessButton();\n}\n```\n\n7. Add visual feedback for drag states in CSS (handled in task 2)",
        "testStrategy": "Testing checklist:\n1. Test drag-and-drop with valid image files (PNG, JPG, WEBP)\n2. Test click-to-browse file picker\n3. Verify rejection of invalid file types (PDF, GIF, etc.)\n4. Test file size validation with files >10MB\n5. Verify preview displays correctly after upload\n6. Test clear upload functionality\n7. Test drag over/leave visual feedback\n8. Test on touch devices (mobile Safari, Chrome Android)\n9. Verify multiple rapid uploads handled gracefully\n10. Test with corrupted/invalid image files\n11. Accessibility: keyboard navigation, screen reader announcements",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:19:57.599Z"
      },
      {
        "id": "5",
        "title": "Integrate remove.bg API for background removal",
        "description": "Implement API integration to remove background from uploaded images with comprehensive error handling",
        "details": "JavaScript implementation for remove.bg API integration:\n\n1. API configuration:\n```javascript\nconst REMOVEBG_ENDPOINT = 'https://api.remove.bg/v1.0/removebg';\n```\n\n2. Main background removal function:\n```javascript\nasync function removeBackground(imageFile) {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    showError('Please enter your remove.bg API key first');\n    return null;\n  }\n  \n  // Show loading state\n  showLoadingState('Removing background...');\n  \n  try {\n    // Prepare FormData\n    const formData = new FormData();\n    formData.append('image_file', imageFile);\n    formData.append('size', 'auto');\n    \n    // Make API request\n    const response = await fetch(REMOVEBG_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'X-Api-Key': apiKey\n      },\n      body: formData\n    });\n    \n    // Handle errors\n    if (!response.ok) {\n      await handleRemoveBgError(response);\n      return null;\n    }\n    \n    // Get blob result\n    const blob = await response.blob();\n    \n    // Check API credits from headers if available\n    const creditsRemaining = response.headers.get('X-Credits-Remaining');\n    if (creditsRemaining) {\n      updateCreditsDisplay(creditsRemaining);\n    }\n    \n    // Convert blob to image for canvas processing\n    const imageUrl = URL.createObjectURL(blob);\n    const img = new Image();\n    await new Promise((resolve, reject) => {\n      img.onload = resolve;\n      img.onerror = reject;\n      img.src = imageUrl;\n    });\n    \n    hideLoadingState();\n    return img;\n    \n  } catch (error) {\n    hideLoadingState();\n    showError('Network error. Please check your connection and try again.');\n    console.error('Remove.bg error:', error);\n    return null;\n  }\n}\n```\n\n3. Error handling:\n```javascript\nasync function handleRemoveBgError(response) {\n  const status = response.status;\n  let errorMessage;\n  \n  try {\n    const errorData = await response.json();\n    errorMessage = errorData.errors?.[0]?.title || 'Unknown error';\n  } catch {\n    errorMessage = 'API request failed';\n  }\n  \n  switch (status) {\n    case 400:\n      showError('Invalid image. Please try a different photo.');\n      break;\n    case 401:\n      showError('Invalid API key. Please check and re-enter your key.');\n      localStorage.removeItem('refi-orbifier-api-key');\n      break;\n    case 402:\n      showError('Insufficient API credits. <a href=\"https://www.remove.bg/pricing\" target=\"_blank\">Upgrade your plan</a>');\n      break;\n    case 429:\n      showError('Rate limit exceeded. Please wait a moment and try again.');\n      break;\n    default:\n      showError(`Error: ${errorMessage}`);\n  }\n}\n```\n\n4. Loading state UI:\n```javascript\nfunction showLoadingState(message) {\n  const loadingEl = document.getElementById('loading');\n  loadingEl.textContent = message;\n  loadingEl.classList.remove('hidden');\n  disableUI();\n}\n\nfunction hideLoadingState() {\n  const loadingEl = document.getElementById('loading');\n  loadingEl.classList.add('hidden');\n  enableUI();\n}\n```\n\n5. Retry mechanism:\n```javascript\nlet processingCache = new Map(); // Cache to avoid re-processing same file\n```",
        "testStrategy": "Testing plan:\n1. Test with valid API key and various portrait images\n2. Test all error scenarios:\n   - Invalid API key (401)\n   - Insufficient credits (402)\n   - Invalid image format (400)\n   - Rate limiting (429)\n   - Network timeout\n3. Verify loading states appear and clear correctly\n4. Test with slow network (throttle in DevTools)\n5. Verify error messages are user-friendly\n6. Test API credit display if header available\n7. Verify blob cleanup (no memory leaks)\n8. Test retry functionality\n9. Mock API responses for automated testing\n10. Verify CORS handling\n11. Test with different image sizes and formats",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:19:59.300Z"
      },
      {
        "id": "6",
        "title": "Create ReFi orb gradient generator with noise texture",
        "description": "Implement canvas-based orb generation with conic gradient, proper color transitions, and subtle noise overlay",
        "details": "JavaScript implementation for orb gradient generation:\n\n1. Orb configuration:\n```javascript\nconst ORB_CONFIG = {\n  size: 320, // diameter in pixels\n  colors: [\n    { stop: 0, color: '#4571E1' },     // Blue\n    { stop: 0.15, color: '#5BC5E8' },  // Cyan\n    { stop: 0.3, color: '#71E3BA' },   // Green  \n    { stop: 0.45, color: '#FFFA7E' },  // Yellow\n    { stop: 0.6, color: '#DE9AE9' },   // Pink\n    { stop: 0.75, color: '#9B6FD6' },  // Purple\n    { stop: 1, color: '#4571E1' }      // Back to Blue\n  ],\n  noiseOpacity: 0.07\n};\n```\n\n2. Generate noise texture:\n```javascript\nfunction generateNoiseTexture(width, height) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  \n  const imageData = ctx.createImageData(width, height);\n  const data = imageData.data;\n  \n  // Generate grayscale noise\n  for (let i = 0; i < data.length; i += 4) {\n    const noise = Math.random() * 255;\n    data[i] = noise;     // R\n    data[i + 1] = noise; // G\n    data[i + 2] = noise; // B\n    data[i + 3] = 255;   // A\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n  return canvas;\n}\n```\n\n3. Draw orb gradient:\n```javascript\nfunction drawOrbGradient(ctx, centerX, centerY, radius) {\n  // Create conic gradient\n  const gradient = ctx.createConicGradient(0, centerX, centerY);\n  \n  // Add color stops\n  ORB_CONFIG.colors.forEach(({ stop, color }) => {\n    gradient.addColorStop(stop, color);\n  });\n  \n  // Draw circle with gradient\n  ctx.save();\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n  ctx.fillStyle = gradient;\n  ctx.fill();\n  ctx.restore();\n}\n```\n\n4. Apply noise overlay:\n```javascript\nfunction applyNoiseOverlay(ctx, width, height, opacity) {\n  const noiseTexture = generateNoiseTexture(width, height);\n  \n  ctx.save();\n  ctx.globalAlpha = opacity;\n  ctx.globalCompositeOperation = 'multiply';\n  ctx.drawImage(noiseTexture, 0, 0);\n  ctx.restore();\n}\n```\n\n5. Fallback for browsers without conic gradient support:\n```javascript\nfunction supportsConicGradient() {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  return typeof ctx.createConicGradient === 'function';\n}\n\n// If not supported, use radial gradient approximation\nfunction drawOrbRadialFallback(ctx, centerX, centerY, radius) {\n  // Create multiple radial segments to approximate conic\n  // Implementation details...\n}\n```",
        "testStrategy": "Testing checklist:\n1. Visual verification: orb matches reference images from PRD\n2. Verify smooth color transitions (no banding)\n3. Test noise texture visibility at different zoom levels\n4. Verify conic gradient browser support (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+)\n5. Test fallback gradient on older browsers\n6. Performance: measure canvas rendering time (<500ms requirement)\n7. Test at different canvas sizes\n8. Verify colors match exact hex codes from PRD\n9. Test noise opacity produces subtle effect (5-10%)\n10. Visual regression testing against approved design",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:20:00.957Z"
      },
      {
        "id": "7",
        "title": "Implement image compositing on canvas",
        "description": "Composite background-removed subject image onto orb background with proper scaling, positioning, and layering",
        "details": "JavaScript implementation for canvas compositing:\n\n1. Canvas setup:\n```javascript\nconst OUTPUT_SIZE = 400; // 400x400px for X profile pictures\n\nfunction createOutputCanvas() {\n  const canvas = document.createElement('canvas');\n  canvas.width = OUTPUT_SIZE;\n  canvas.height = OUTPUT_SIZE;\n  return canvas;\n}\n```\n\n2. Main compositing function:\n```javascript\nasync function compositeOrbifiedImage(foregroundImg) {\n  const canvas = createOutputCanvas();\n  const ctx = canvas.getContext('2d', { alpha: false });\n  \n  // Layer 1: Solid background\n  ctx.fillStyle = '#172027'; // ReFi Space\n  ctx.fillRect(0, 0, OUTPUT_SIZE, OUTPUT_SIZE);\n  \n  // Layer 2: Orb gradient\n  const orbRadius = 160; // ~320px diameter\n  const centerX = OUTPUT_SIZE / 2;\n  const centerY = OUTPUT_SIZE / 2;\n  drawOrbGradient(ctx, centerX, centerY, orbRadius);\n  \n  // Layer 3: Noise texture overlay\n  applyNoiseOverlay(ctx, OUTPUT_SIZE, OUTPUT_SIZE, ORB_CONFIG.noiseOpacity);\n  \n  // Layer 4: Foreground image (subject)\n  compositeForeground(ctx, foregroundImg);\n  \n  return canvas;\n}\n```\n\n3. Foreground positioning logic:\n```javascript\nfunction compositeForeground(ctx, img) {\n  const imgAspect = img.width / img.height;\n  let drawWidth, drawHeight;\n  \n  // Scale to fit nicely within orb\n  // Target: subject fills ~70% of canvas height\n  const targetHeight = OUTPUT_SIZE * 0.7;\n  drawHeight = targetHeight;\n  drawWidth = drawHeight * imgAspect;\n  \n  // If too wide, scale by width instead\n  if (drawWidth > OUTPUT_SIZE * 0.7) {\n    drawWidth = OUTPUT_SIZE * 0.7;\n    drawHeight = drawWidth / imgAspect;\n  }\n  \n  // Position: centered horizontally, head in top third\n  const x = (OUTPUT_SIZE - drawWidth) / 2;\n  const y = OUTPUT_SIZE * 0.15; // Top third positioning\n  \n  ctx.drawImage(img, x, y, drawWidth, drawHeight);\n}\n```\n\n4. Alternative: Smart crop/position based on face detection (optional enhancement):\n```javascript\n// If face detection API available, could center on detected face\n// For MVP, use simple top-third positioning\n```\n\n5. Canvas to blob for download:\n```javascript\nfunction canvasToBlob(canvas) {\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => {\n      resolve(blob);\n    }, 'image/png', 1.0); // Max quality\n  });\n}\n```\n\n6. Preview display:\n```javascript\nfunction displayPreview(canvas) {\n  const previewImg = document.getElementById('result-preview');\n  previewImg.src = canvas.toDataURL('image/png');\n  \n  const resultSection = document.getElementById('result-section');\n  resultSection.hidden = false;\n  resultSection.scrollIntoView({ behavior: 'smooth' });\n}\n```\n\n7. Main processing pipeline:\n```javascript\nasync function processImage() {\n  if (!window.uploadedFile) return;\n  \n  // Step 1: Remove background\n  const foregroundImg = await removeBackground(window.uploadedFile);\n  if (!foregroundImg) return; // Error handled in removeBackground\n  \n  // Step 2: Composite with orb\n  showLoadingState('Creating your orb...');\n  const outputCanvas = await compositeOrbifiedImage(foregroundImg);\n  hideLoadingState();\n  \n  // Step 3: Display preview\n  displayPreview(outputCanvas);\n  \n  // Step 4: Store for download\n  window.outputCanvas = outputCanvas;\n}\n```",
        "testStrategy": "Testing plan:\n1. Test with portrait images of varying aspect ratios\n2. Verify subject is well-framed within the orb\n3. Test with landscape and square images\n4. Verify layering order: background > orb > noise > subject\n5. Check output is exactly 400x400px\n6. Verify image quality (no pixelation or artifacts)\n7. Test canvas rendering performance (<500ms)\n8. Visual comparison: output matches reference images\n9. Test with very tall/wide images (edge cases)\n10. Verify transparency from remove.bg preserved correctly\n11. Test preview displays accurately\n12. Memory leak testing (multiple successive operations)",
        "priority": "high",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:20:02.588Z"
      },
      {
        "id": "8",
        "title": "Implement download functionality",
        "description": "Enable users to download the orbified image as a PNG file with proper naming and cross-browser support",
        "details": "JavaScript implementation for download functionality:\n\n1. Download button handler:\n```javascript\nconst downloadBtn = document.getElementById('download-btn');\n\ndownloadBtn.addEventListener('click', async () => {\n  if (!window.outputCanvas) {\n    showError('No image to download');\n    return;\n  }\n  \n  await downloadOrbifiedImage();\n});\n```\n\n2. Main download function:\n```javascript\nasync function downloadOrbifiedImage() {\n  const canvas = window.outputCanvas;\n  const filename = 'refi-orbified-pfp.png';\n  \n  try {\n    // Convert canvas to blob\n    const blob = await canvasToBlob(canvas);\n    \n    // Create download link\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    \n    // Trigger download\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    \n    // Cleanup\n    setTimeout(() => URL.revokeObjectURL(url), 100);\n    \n    // Show success feedback\n    showSuccessMessage('Image downloaded! Ready to share.');\n    \n  } catch (error) {\n    console.error('Download error:', error);\n    showError('Failed to download image. Please try again.');\n  }\n}\n```\n\n3. iOS/Safari fallback (if needed):\n```javascript\nfunction downloadForiOS(canvas, filename) {\n  // iOS Safari doesn't support download attribute well\n  // Open in new tab for user to long-press and save\n  const dataURL = canvas.toDataURL('image/png');\n  const newWindow = window.open();\n  newWindow.document.write(`\n    <img src=\"${dataURL}\" alt=\"Orbified profile picture\" />\n    <p>Long-press the image and tap \"Save Image\"</p>\n  `);\n}\n```\n\n4. Mobile detection:\n```javascript\nfunction isMobileSafari() {\n  const ua = navigator.userAgent;\n  return /iP(ad|hone|od)/.test(ua) && /Safari/.test(ua);\n}\n```\n\n5. Enhanced download with analytics (optional):\n```javascript\nfunction trackDownload() {\n  // If analytics added later, track successful downloads\n  // For now, just increment localStorage counter\n  const count = parseInt(localStorage.getItem('refi-download-count') || '0');\n  localStorage.setItem('refi-download-count', (count + 1).toString());\n}\n```",
        "testStrategy": "Testing checklist:\n1. Test download on Chrome, Firefox, Safari, Edge (desktop)\n2. Test on mobile browsers: Safari iOS, Chrome Android, Firefox Android\n3. Verify filename is 'refi-orbified-pfp.png'\n4. Verify downloaded file is valid PNG, 400x400px\n5. Verify image quality matches preview\n6. Test download multiple times in succession\n7. Test on iOS Safari (may need fallback behavior)\n8. Verify blob URLs are cleaned up (no memory leaks)\n9. Test with disabled JavaScript (graceful degradation)\n10. Verify download works in incognito/private mode\n11. Test accessibility: keyboard trigger, screen reader announcement",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:20:04.275Z"
      },
      {
        "id": "9",
        "title": "Add Twitter/X share functionality",
        "description": "Implement share button that opens Twitter Web Intent with pre-filled tweet mentioning @ReFiDAOist and @iamjohnellison",
        "details": "JavaScript implementation for Twitter sharing:\n\n1. Tweet template configuration:\n```javascript\nconst TWEET_CONFIG = {\n  text: `Just orbified my PFP with the ReFi Orbifier! ðŸŒˆ\\n\\nThanks @ReFiDAOist & @iamjohnellison for this awesome tool!\\n\\n#ReFi #RegenerativeFinance\\n\\n[Attach your downloaded image]`,\n  url: 'https://twitter.com/intent/tweet'\n};\n```\n\n2. Share button handler:\n```javascript\nconst shareBtn = document.getElementById('share-btn');\n\nshareBtn.addEventListener('click', () => {\n  shareToTwitter();\n});\n```\n\n3. Main share function:\n```javascript\nfunction shareToTwitter() {\n  // Encode tweet text for URL\n  const encodedText = encodeURIComponent(TWEET_CONFIG.text);\n  \n  // Build Twitter Web Intent URL\n  const tweetUrl = `${TWEET_CONFIG.url}?text=${encodedText}`;\n  \n  // Open in new window/tab\n  const width = 550;\n  const height = 420;\n  const left = (screen.width - width) / 2;\n  const top = (screen.height - height) / 2;\n  \n  window.open(\n    tweetUrl,\n    'twitter-share',\n    `width=${width},height=${height},left=${left},top=${top}`\n  );\n  \n  // Show reminder to attach image\n  showInfo('Remember to attach your downloaded image to the tweet!');\n}\n```\n\n4. Alternative: Copy tweet text to clipboard:\n```javascript\nasync function copyTweetToClipboard() {\n  try {\n    await navigator.clipboard.writeText(TWEET_CONFIG.text);\n    showSuccessMessage('Tweet text copied! Paste in Twitter.');\n  } catch (error) {\n    // Fallback for older browsers\n    fallbackCopyToClipboard(TWEET_CONFIG.text);\n  }\n}\n\nfunction fallbackCopyToClipboard(text) {\n  const textarea = document.createElement('textarea');\n  textarea.value = text;\n  textarea.style.position = 'fixed';\n  textarea.style.opacity = '0';\n  document.body.appendChild(textarea);\n  textarea.select();\n  document.execCommand('copy');\n  document.body.removeChild(textarea);\n  showSuccessMessage('Tweet text copied!');\n}\n```\n\n5. Enhanced UI feedback:\n```javascript\n// Update share button to show it opens external site\nshareBtn.innerHTML = `\n  <svg><!-- Twitter/X icon --></svg>\n  Share on X\n  <svg><!-- External link icon --></svg>\n`;\n```\n\n6. Add instructional tooltip:\n```html\n<div class=\"share-instructions\">\n  <p>Note: After clicking Share, you'll need to manually attach your downloaded image to the tweet.</p>\n</div>\n```",
        "testStrategy": "Testing plan:\n1. Test share button opens Twitter Web Intent\n2. Verify tweet text is correctly pre-filled\n3. Verify all mentions included: @ReFiDAOist, @iamjohnellison\n4. Verify hashtags included: #ReFi, #RegenerativeFinance\n5. Test on desktop and mobile browsers\n6. Verify popup dimensions and positioning\n7. Test with popup blockers enabled\n8. Verify instruction about attaching image is clear\n9. Test copy-to-clipboard fallback functionality\n10. Verify external link icon/indicator present\n11. Test accessibility: keyboard navigation, screen reader\n12. Verify new window has appropriate name/target",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-13T14:20:05.990Z"
      },
      {
        "id": "10",
        "title": "Create assets and implement accessibility enhancements",
        "description": "Generate favicon and OG image, implement WCAG 2.1 AA compliance, keyboard navigation, and screen reader support",
        "details": "Implementation of remaining assets and accessibility features:\n\n1. Assets creation:\n   - Create assets/ directory\n   - Generate favicon.ico (32x32, 16x16) with ReFi orb design\n   - Generate og-image.png (1200x630) showing app preview for social sharing\n   - Link favicon in <head>: <link rel=\"icon\" href=\"assets/favicon.ico\">\n   - Update og:image meta tag to point to assets/og-image.png\n\n2. Keyboard navigation:\n```javascript\n// Ensure all interactive elements are keyboard accessible\ndocument.addEventListener('keydown', (e) => {\n  // Enter key triggers buttons\n  if (e.key === 'Enter' && e.target.tagName === 'BUTTON') {\n    e.target.click();\n  }\n  \n  // Escape closes modals/errors\n  if (e.key === 'Escape') {\n    closeAllModals();\n  }\n});\n\n// Tab trap for upload dropzone\ndropzone.setAttribute('tabindex', '0');\ndropzone.addEventListener('keypress', (e) => {\n  if (e.key === 'Enter' || e.key === ' ') {\n    fileInput.click();\n  }\n});\n```\n\n3. ARIA labels and roles:\n```html\n<section id=\"upload-section\" role=\"region\" aria-label=\"Upload your photo\">\n  <div id=\"dropzone\" \n       role=\"button\" \n       tabindex=\"0\"\n       aria-label=\"Click or drop photo to upload\">\n  </div>\n</section>\n\n<div id=\"loading\" \n     role=\"status\" \n     aria-live=\"polite\" \n     aria-atomic=\"true\">\n</div>\n\n<div id=\"error-message\" \n     role=\"alert\" \n     aria-live=\"assertive\">\n</div>\n```\n\n4. Focus management:\n```javascript\nfunction showLoadingState(message) {\n  const loadingEl = document.getElementById('loading');\n  loadingEl.textContent = message;\n  loadingEl.classList.remove('hidden');\n  // Announce to screen readers\n  loadingEl.setAttribute('aria-busy', 'true');\n}\n\nfunction hideLoadingState() {\n  const loadingEl = document.getElementById('loading');\n  loadingEl.classList.add('hidden');\n  loadingEl.setAttribute('aria-busy', 'false');\n}\n```\n\n5. Color contrast verification:\n   - Ensure all text meets 4.5:1 contrast ratio\n   - Test with browser DevTools contrast checker\n   - ReFi Cloud (#F1F0FF) on ReFi Space (#172027) = 12.7:1 âœ“\n\n6. Focus indicators in CSS:\n```css\n*:focus {\n  outline: 2px solid var(--refi-blue);\n  outline-offset: 2px;\n}\n\n*:focus:not(:focus-visible) {\n  outline: none;\n}\n\n*:focus-visible {\n  outline: 2px solid var(--refi-blue);\n  outline-offset: 2px;\n}\n```\n\n7. Screen reader only text:\n```html\n<span class=\"sr-only\">Removing background, please wait</span>\n```\n\n```css\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border: 0;\n}\n```\n\n8. Skip to main content link:\n```html\n<a href=\"#main\" class=\"skip-link\">Skip to main content</a>\n```\n\n9. Image alt text:\n```javascript\nuploadPreview.alt = 'Your uploaded profile photo';\nresultPreview.alt = 'Your orbified profile picture';\n```",
        "testStrategy": "Testing checklist:\n1. Run axe DevTools accessibility audit (0 violations)\n2. Run WAVE accessibility evaluation\n3. Test with screen readers: VoiceOver (Mac), NVDA (Windows), TalkBack (Android)\n4. Keyboard-only navigation test (no mouse)\n5. Verify all interactive elements reachable via Tab\n6. Test focus indicators visible and clear\n7. Color contrast verification with tools\n8. Test with Windows High Contrast Mode\n9. Test with browser zoom at 200%\n10. Verify ARIA live regions announce status changes\n11. Test favicon displays in browser tabs\n12. Test OG image preview on Twitter, Facebook, LinkedIn\n13. Validate HTML with W3C validator\n14. Test skip link functionality\n15. Verify all images have descriptive alt text",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T14:37:26.776Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-14T14:37:26.776Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}